
<!DOCTYPE html>
<html lang="en">
    <head>
        <title>vue.js</title>
        <meta charset="utf-8">
        <meta name="description" content="Vue.js - Intuitive, Fast and Composable MVVM for building interactive interfaces.">
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
        <meta property="og:type" content="article">
        <meta property="og:title" content="vue.js">
        <meta property="og:description" content="Vue.js - Intuitive, Fast and Composable MVVM for building interactive interfaces.">
        <meta property="og:image" content="https://cn.vuejs.org/images/logo.png">

        <meta name="twitter:card" content="summary">
        <meta name="twitter:title" content="vue.js">
        <meta name="twitter:description" content="Vue.js - Intuitive, Fast and Composable MVVM for building interactive interfaces.">
        <meta name="twitter:image" content="https://cn.vuejs.org/images/logo.png">

        <link rel="icon" href="/images/logo.png" type="image/x-icon">

        <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,600|Roboto Mono' rel='stylesheet' type='text/css'>
        <link href='//fonts.googleapis.com/css?family=Dosis:500&text=Vue.js' rel='stylesheet' type='text/css'>

        <!-- main page styles -->
        <link rel="stylesheet" href="/css/page.css">

        <!-- this needs to be loaded before guide's inline scripts -->
        <script src="/js/vue.js"></script>
        <script>window.PAGE_TYPE = "api"</script>
    </head>
    <body class="docs">        <div id="mobile-bar" >
            <a class="menu-button"></a>
            <a class="logo" href="/"></a>
        </div>
        <div id="header">
  <a id="logo" href="/">
    <img src="/images/logo.png">
    <span>Vue.js</span>
  </a>
  <ul id="nav">
    <li>
  <form id="search-form">
    <input type="text" id="search-query-nav" class="search-query st-default-search-input">
  </form>
</li>
<li><a href="/v2/guide/" class="nav-link">教程</a></li>
<li><a href="/v2/api/" class="nav-link current">API</a></li>
<li><a href="/v2/examples/" class="nav-link">示例</a></li>
<li><a href="/about/" class="nav-link">参与贡献</a></li>
<li class="nav-dropdown-container">
  <a class="nav-link">社区</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><a href="https://github.com/vuejs/vue" class="nav-link" target="_blank">GitHub</a></li>
    <li><a href="http://forum.vuejs.org" class="nav-link" target="_blank">论坛</a></li>
    <li><a href="https://gitter.im/vuejs/vue" class="nav-link" target="_blank">聊天室</a></li>
    <li><a href="https://twitter.com/vuejs" class="nav-link" target="_blank">Twitter</a></li>
    <li><a href="https://vuejsjob.com/?ref=vuejs" class="nav-link" target="_blank">工作</a></li>
  </ul>
</li>

<li class="nav-dropdown-container ecosystem">
  <a class="nav-link">生态系统</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><h4>帮助</h4></li>
    <li><ul>
      <li><a href="http://forum.vuejs.org" class="nav-link" target="_blank">论坛</a></li>
      <li><a href="https://gitter.im/vuejs/vue" class="nav-link" target="_blank">聊天室</a></li>
      <li><a href="https://github.com/vuejs-templates" class="nav-link" target="_blank">模板</a></li>
    </ul></li>
    <li><h4>信息</h4></li>
    <li><ul>
      <li><a href="https://twitter.com/vuejs" class="nav-link" target="_blank">Twitter</a></li>
      <li><a href="https://medium.com/the-vue-point" class="nav-link" target="_blank">博客</a></li>
      <li><a href="https://vuejobs.com/?ref=vuejs" class="nav-link" target="_blank">工作</a></li>
    </ul></li>
    <li><h4>核心插件</h4></li>
    <li><ul>
      <li><a href="https://router.vuejs.org/" class="nav-link" target="_blank">Vue Router</a></li>
      <li><a href="https://vuex.vuejs.org/" class="nav-link" target="_blank">Vuex</a></li>
    </ul></li>
    <li><h4>资源列表</h4></li>
    <li><ul>
      <li><a href="https://github.com/vuejs" class="nav-link" target="_blank">官方仓库</a></li>
      <li><a href="https://github.com/vuejs/awesome-vue" class="nav-link" target="_blank">Vue 资源</a></li>
    </ul></li>
  </ul>
</li>
<li class="nav-dropdown-container language">
  <a class="nav-link">多语言</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><a href="https://cn.vuejs.org/" class="nav-link" target="_blank">中文</a></li>
    <li><a href="https://vuejs.org/" class="nav-link" target="_blank">English</a></li>
    <li><a href="https://jp.vuejs.org/" class="nav-link" target="_blank">日本語</a></li>
    <li><a href="https://ru.vuejs.org/" class="nav-link" target="_blank">Русский</a></li>
    <li><a href="https://kr.vuejs.org/" class="nav-link" target="_blank">한국어</a></li>
  </ul>
</li>

  </ul>
</div>

        
            <div id="main" class="fix-sidebar">
                
                    
    <div class="sidebar">
    <ul class="main-menu">
        <li>
  <form id="search-form">
    <input type="text" id="search-query-sidebar" class="search-query st-default-search-input">
  </form>
</li>
<li><a href="/v2/guide/" class="nav-link">教程</a></li>
<li><a href="/v2/api/" class="nav-link current">API</a></li>
<li><a href="/v2/examples/" class="nav-link">示例</a></li>
<li><a href="/about/" class="nav-link">参与贡献</a></li>
<li class="nav-dropdown-container">
  <a class="nav-link">社区</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><a href="https://github.com/vuejs/vue" class="nav-link" target="_blank">GitHub</a></li>
    <li><a href="http://forum.vuejs.org" class="nav-link" target="_blank">论坛</a></li>
    <li><a href="https://gitter.im/vuejs/vue" class="nav-link" target="_blank">聊天室</a></li>
    <li><a href="https://twitter.com/vuejs" class="nav-link" target="_blank">Twitter</a></li>
    <li><a href="https://vuejsjob.com/?ref=vuejs" class="nav-link" target="_blank">工作</a></li>
  </ul>
</li>

<li class="nav-dropdown-container ecosystem">
  <a class="nav-link">生态系统</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><h4>帮助</h4></li>
    <li><ul>
      <li><a href="http://forum.vuejs.org" class="nav-link" target="_blank">论坛</a></li>
      <li><a href="https://gitter.im/vuejs/vue" class="nav-link" target="_blank">聊天室</a></li>
      <li><a href="https://github.com/vuejs-templates" class="nav-link" target="_blank">模板</a></li>
    </ul></li>
    <li><h4>信息</h4></li>
    <li><ul>
      <li><a href="https://twitter.com/vuejs" class="nav-link" target="_blank">Twitter</a></li>
      <li><a href="https://medium.com/the-vue-point" class="nav-link" target="_blank">博客</a></li>
      <li><a href="https://vuejobs.com/?ref=vuejs" class="nav-link" target="_blank">工作</a></li>
    </ul></li>
    <li><h4>核心插件</h4></li>
    <li><ul>
      <li><a href="https://router.vuejs.org/" class="nav-link" target="_blank">Vue Router</a></li>
      <li><a href="https://vuex.vuejs.org/" class="nav-link" target="_blank">Vuex</a></li>
    </ul></li>
    <li><h4>资源列表</h4></li>
    <li><ul>
      <li><a href="https://github.com/vuejs" class="nav-link" target="_blank">官方仓库</a></li>
      <li><a href="https://github.com/vuejs/awesome-vue" class="nav-link" target="_blank">Vue 资源</a></li>
    </ul></li>
  </ul>
</li>
<li class="nav-dropdown-container language">
  <a class="nav-link">多语言</a><span class="arrow"></span>
  <ul class="nav-dropdown">
    <li><a href="https://cn.vuejs.org/" class="nav-link" target="_blank">中文</a></li>
    <li><a href="https://vuejs.org/" class="nav-link" target="_blank">English</a></li>
    <li><a href="https://jp.vuejs.org/" class="nav-link" target="_blank">日本語</a></li>
    <li><a href="https://ru.vuejs.org/" class="nav-link" target="_blank">Русский</a></li>
    <li><a href="https://kr.vuejs.org/" class="nav-link" target="_blank">한국어</a></li>
  </ul>
</li>

    </ul>
    <div class="list">
        <div class="main-sponsor">
            <span>赞助者</span><br>
            <a href="http://www.thedifferenceengine.io/" target="_blank"
                style="background-color: #f3f3f3; padding: 10px 0">
                <img src="/images/tde.png">
            </a>
        </div>
        <a class="become-backer" href="/support-vuejs">
            成为赞助者
        </a>
        <h2>
            
            
                <select class="version-select">
                    <option value="SELF" selected>2.0</option>
                    <option value="v1">1.0</option>
                </select>
            
        </h2>
        <ul class="menu-root">
            
            
        </ul>
    </div>
</div>


<div class="content api with-sidebar ">
    
    
    <h2 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h2><p><code>Vue.config</code>  是一个对象，包含 Vue 的全局配置。可以在启动应用之前修改下列属性：</p>
<h3 id="silent"><a href="#silent" class="headerlink" title="silent"></a>silent</h3><ul>
<li><p><strong>类型：</strong> <code>boolean</code></p>
</li>
<li><p><strong>默认值：</strong> <code>false</code></p>
</li>
<li><p><strong>用法：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">Vue.config.silent = <span class="literal">true</span></div></pre></td></tr></table></figure>
<p>取消 Vue 所有的日志与警告。</p>
</li>
</ul>
<h3 id="optionMergeStrategies"><a href="#optionMergeStrategies" class="headerlink" title="optionMergeStrategies"></a>optionMergeStrategies</h3><ul>
<li><p><strong>类型：</strong> <code>{ [key: string]: Function }</code></p>
</li>
<li><p><strong>默认值：</strong> <code>{}</code></p>
</li>
<li><p><strong>用法：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">Vue.config.optionMergeStrategies._my_option = <span class="function"><span class="keyword">function</span> (<span class="params">parent, child, vm</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> child + <span class="number">1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> Profile = Vue.extend(&#123;</div><div class="line">  <span class="attr">_my_option</span>: <span class="number">1</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// Profile.options._my_option = 2</span></div></pre></td></tr></table></figure>
<p>自定义合并策略的选项。</p>
<p>合并策略选项分别接受第一个参数作为父实例，第二个参数为子实例，Vue实例上下文被作为第三个参数传入。</p>
</li>
<li><p><strong>参考</strong> <a href="../guide/mixins.html#自定义选项混合策略">自定义选项的混合策略</a></p>
</li>
</ul>
<h3 id="devtools"><a href="#devtools" class="headerlink" title="devtools"></a>devtools</h3><ul>
<li><p><strong>类型：</strong> <code>boolean</code></p>
</li>
<li><p><strong>默认值：</strong> <code>true</code> (生产版为 <code>false</code>)</p>
</li>
<li><p><strong>用法：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 务必在加载 Vue 之后，立即同步设置以下内容</span></div><div class="line">Vue.config.devtools = <span class="literal">true</span></div></pre></td></tr></table></figure>
<p>配置是否允许 <a href="https://github.com/vuejs/vue-devtools" target="_blank" rel="external">vue-devtools</a> 检查代码。开发版本默认为 <code>true</code>，生产版本默认为 <code>false</code>。生产版本设为 <code>true</code> 可以启用检查。</p>
</li>
</ul>
<h3 id="errorHandler"><a href="#errorHandler" class="headerlink" title="errorHandler"></a>errorHandler</h3><ul>
<li><p><strong>类型：</strong> <code>Function</code></p>
</li>
<li><p><strong>默认值：</strong> 默认抛出错误</p>
</li>
<li><p><strong>用法：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">Vue.config.errorHandler = <span class="function"><span class="keyword">function</span> (<span class="params">err, vm</span>) </span>&#123;</div><div class="line">  <span class="comment">// handle error</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例。</p>
<blockquote>
<p><a href="https://sentry.io" target="_blank" rel="external">Sentry</a>, an error tracking service, provides <a href="https://sentry.io/for/vue/" target="_blank" rel="external">official integration</a> using this option.</p>
</blockquote>
</li>
</ul>
<h3 id="ignoredElements"><a href="#ignoredElements" class="headerlink" title="ignoredElements"></a>ignoredElements</h3><ul>
<li><p><strong>类型:</strong> <code>Array&lt;string&gt;</code></p>
</li>
<li><p><strong>默认值:</strong> <code>[]</code></p>
</li>
<li><p><strong>用法:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">Vue.config.ignoredElements = [</div><div class="line">  <span class="string">'my-custom-web-component'</span>, <span class="string">'another-web-component'</span></div><div class="line">]</div></pre></td></tr></table></figure>
<p>须使 Vue 忽略在 Vue 之外的自定义元素 (e.g., 使用了 Web Components APIs)。否则，它会假设你忘记注册全局组件或者拼错了组件名称，从而抛出一个关于 <code>Unknown custom element</code> 的警告。</p>
</li>
</ul>
<h3 id="keyCodes"><a href="#keyCodes" class="headerlink" title="keyCodes"></a>keyCodes</h3><ul>
<li><p><strong>类型：</strong> <code>{ [key: string]: number | Array&lt;number&gt; }</code></p>
</li>
<li><p><strong>默认值：</strong> <code>{}</code></p>
</li>
<li><p><strong>用法：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">Vue.config.keyCodes = &#123;</div><div class="line">  <span class="attr">v</span>: <span class="number">86</span>,</div><div class="line">  <span class="attr">f1</span>: <span class="number">112</span>,</div><div class="line">  <span class="attr">mediaPlayPause</span>: <span class="number">179</span>,</div><div class="line">  <span class="attr">up</span>: [<span class="number">38</span>, <span class="number">87</span>]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>给 v-on 自定义键位别名。</p>
</li>
</ul>
<h2 id="全局-API"><a href="#全局-API" class="headerlink" title="全局 API"></a>全局 API</h2><h3 id="Vue-extend">Vue.extend( options )</h3>

<ul>
<li><p><strong>参数：</strong></p>
<ul>
<li><code>{Object} options</code></li>
</ul>
</li>
<li><p><strong>用法：</strong></p>
<p>使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。</p>
<p><code>data</code> 选项是特例，需要注意 - 在 <code>Vue.extend()</code> 中它必须是函数</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"mount-point"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 创建构造器</span></div><div class="line"><span class="keyword">var</span> Profile = Vue.extend(&#123;</div><div class="line">  <span class="attr">template</span>: <span class="string">'&lt;p&gt;&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125; aka &#123;&#123;alias&#125;&#125;&lt;/p&gt;'</span>,</div><div class="line">  <span class="attr">data</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      <span class="attr">firstName</span>: <span class="string">'Walter'</span>,</div><div class="line">      <span class="attr">lastName</span>: <span class="string">'White'</span>,</div><div class="line">      <span class="attr">alias</span>: <span class="string">'Heisenberg'</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line"><span class="comment">// 创建 Profile 实例，并挂载到一个元素上。</span></div><div class="line"><span class="keyword">new</span> Profile().$mount(<span class="string">'#mount-point'</span>)</div></pre></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Walter White aka Heisenberg<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>参考：</strong> <a href="../guide/components.html">组件</a></p>
</li>
</ul>
<h3 id="Vue-nextTick">Vue.nextTick( [callback, context] )</h3>

<ul>
<li><p><strong>参数：</strong></p>
<ul>
<li><code>{Function} [callback]</code></li>
<li><code>{Object} [context]</code></li>
</ul>
</li>
<li><p><strong>用法：</strong></p>
<p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 修改数据</span></div><div class="line">vm.msg = <span class="string">'Hello'</span></div><div class="line"><span class="comment">// DOM 还没有更新</span></div><div class="line">Vue.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// DOM 更新了</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<blockquote>
<p>2.1.0新增：如果没有提供回调且支持 promise 的环境中返回 promise。</p>
</blockquote>
</li>
<li><p><strong>参考：</strong> <a href="../guide/reactivity.html#异步更新队列">异步更新队列</a></p>
</li>
</ul>
<h3 id="Vue-set">Vue.set( object, key, value )</h3>

<ul>
<li><p><strong>参数：</strong></p>
<ul>
<li><code>{Object} object</code></li>
<li><code>{string} key</code></li>
<li><code>{any} value</code></li>
</ul>
</li>
<li><p><strong>返回值：</strong> 设置的值.</p>
</li>
<li><p><strong>用法：</strong></p>
<p>设置对象的属性。如果对象是响应式的，确保属性被创建后也是响应式的，同时触发视图更新。这个方法主要用于避开 Vue 不能检测属性被添加的限制。</p>
<p><strong>注意对象不能是 Vue 实例，或者 Vue 实例的根数据对象</strong></p>
</li>
<li><p><strong>参考：</strong> <a href="../guide/reactivity.html">深入响应式原理</a></p>
</li>
</ul>
<h3 id="Vue-delete">Vue.delete( object, key )</h3>

<ul>
<li><p><strong>参数：</strong></p>
<ul>
<li><code>{Object} object</code></li>
<li><code>{string} key</code></li>
</ul>
</li>
<li><p><strong>用法：</strong></p>
<p>删除对象的属性。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开 Vue 不能检测到属性被删除的限制，但是你应该很少会使用它。</p>
<p><strong>注意对象不能是 Vue 实例，或者 Vue 实例的根数据对象</strong></p>
</li>
<li><p><strong>参考：</strong> <a href="../guide/reactivity.html">深入响应式原理</a></p>
</li>
</ul>
<h3 id="Vue-directive">Vue.directive( id, [definition] )</h3>

<ul>
<li><p><strong>参数：</strong></p>
<ul>
<li><code>{string} id</code></li>
<li><code>{Function | Object} [definition]</code></li>
</ul>
</li>
<li><p><strong>用法：</strong></p>
<p>注册或获取全局指令。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 注册</span></div><div class="line">Vue.directive(<span class="string">'my-directive'</span>, &#123;</div><div class="line">  <span class="attr">bind</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">  <span class="attr">inserted</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">  <span class="attr">update</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">  <span class="attr">componentUpdated</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">  <span class="attr">unbind</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 注册（传入一个简单的指令函数）</span></div><div class="line">Vue.directive(<span class="string">'my-directive'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// 这里将会被 `bind` 和 `update` 调用</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// getter，返回已注册的指令</span></div><div class="line"><span class="keyword">var</span> myDirective = Vue.directive(<span class="string">'my-directive'</span>)</div></pre></td></tr></table></figure>
</li>
<li><p><strong>参考：</strong> <a href="../guide/custom-directive.html">自定义指令</a></p>
</li>
</ul>
<h3 id="Vue-filter">Vue.filter( id, [definition] )</h3>

<ul>
<li><p><strong>参数：</strong></p>
<ul>
<li><code>{string} id</code></li>
<li><code>{Function} [definition]</code></li>
</ul>
</li>
<li><p><strong>用法：</strong></p>
<p>注册或获取全局过滤器。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 注册</span></div><div class="line">Vue.filter(<span class="string">'my-filter'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">  <span class="comment">// 返回处理后的值</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// getter，返回已注册的过滤器</span></div><div class="line"><span class="keyword">var</span> myFilter = Vue.filter(<span class="string">'my-filter'</span>)</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Vue-component">Vue.component( id, [definition] )</h3>

<ul>
<li><p><strong>参数：</strong></p>
<ul>
<li><code>{string} id</code></li>
<li><code>{Function | Object} [definition]</code></li>
</ul>
</li>
<li><p><strong>用法：</strong></p>
<p>注册或获取全局组件。注册还会自动使用给定的<code>id</code>设置组件的名称</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 注册组件，传入一个扩展过的构造器</span></div><div class="line">Vue.component(<span class="string">'my-component'</span>, Vue.extend(&#123; <span class="comment">/* ... */</span> &#125;))</div><div class="line"></div><div class="line"><span class="comment">// 注册组件，传入一个选项对象（自动调用 Vue.extend）</span></div><div class="line">Vue.component(<span class="string">'my-component'</span>, &#123; <span class="comment">/* ... */</span> &#125;)</div><div class="line"></div><div class="line"><span class="comment">// 获取注册的组件（始终返回构造器）</span></div><div class="line"><span class="keyword">var</span> MyComponent = Vue.component(<span class="string">'my-component'</span>)</div></pre></td></tr></table></figure>
</li>
<li><p><strong>参考：</strong> <a href="../guide/components.html">组件</a></p>
</li>
</ul>
<h3 id="Vue-use">Vue.use( plugin )</h3>

<ul>
<li><p><strong>参数：</strong></p>
<ul>
<li><code>{Object | Function} plugin</code></li>
</ul>
</li>
<li><p><strong>用法：</strong></p>
<p>安装 Vue.js 插件。如果插件是一个对象，必须提供 <code>install</code> 方法。如果插件是一个函数，它会被作为 install 方法。install 方法将被作为 Vue 的参数调用。</p>
<p>当 install 方法被同一个插件多次调用，插件将只会被安装一次。</p>
</li>
<li><p><strong>参考：</strong> <a href="../guide/plugins.html">插件</a></p>
</li>
</ul>
<h3 id="Vue-mixin">Vue.mixin( mixin )</h3>

<ul>
<li><p><strong>参数：</strong></p>
<ul>
<li><code>{Object} mixin</code></li>
</ul>
</li>
<li><p><strong>用法：</strong></p>
<p>全局注册一个混合，影响注册之后所有创建的每个 Vue 实例。插件作者可以使用混合，向组件注入自定义的行为。<strong>不推荐在应用代码中使用</strong>。</p>
</li>
<li><p><strong>参考：</strong> <a href="../guide/mixins.html#全局混合">全局混合</a></p>
</li>
</ul>
<h3 id="Vue-compile">Vue.compile( template )</h3>

<ul>
<li><p><strong>参数：</strong></p>
<ul>
<li><code>{string} template</code></li>
</ul>
</li>
<li><p><strong>用法：</strong></p>
<p>在render函数中编译模板字符串。<strong>只在独立构建时有效</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> res = Vue.compile(<span class="string">'&lt;div&gt;&lt;span&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;&lt;/div&gt;'</span>)</div><div class="line"></div><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="attr">data</span>: &#123;</div><div class="line">    <span class="attr">msg</span>: <span class="string">'hello'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">render</span>: res.render,</div><div class="line">  <span class="attr">staticRenderFns</span>: res.staticRenderFns</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p><strong>参考：</strong> <a href="../guide/render-function.html">Render 函数</a></p>
</li>
</ul>
<h2 id="选项-数据"><a href="#选项-数据" class="headerlink" title="选项 / 数据"></a>选项 / 数据</h2><h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><ul>
<li><p><strong>类型：</strong> <code>Object | Function</code></p>
</li>
<li><p><strong>限制:</strong> 组件的定义只接受 <code>function</code>。</p>
</li>
<li><p><strong>详细:</strong></p>
<p>Vue 实例的数据对象。Vue 将会递归将 data 的属性转换为 getter/setter，从而让 data 的属性能够响应数据变化。<strong>对象必须是纯粹的对象(含有零个或多个的key/value对)</strong>：浏览器 API 创建的原生对象，原型上的属性会被忽略。大概来说，data 应该只能是数据 - 不推荐观察拥有状态行为的对象。</p>
<p>一旦观察过，不需要再次在数据对象上添加响应式属性。因此推荐在创建实例之前，就声明所有的根级响应式属性。</p>
<p>实例创建之后，可以通过 <code>vm.$data</code> 访问原始数据对象。Vue 实例也代理了 data 对象上所有的属性，因此访问 <code>vm.a</code> 等价于访问 <code>vm.$data.a</code>。</p>
<p>以 <code>_</code> 或 <code>$</code> 开头的属性 <strong>不会</strong> 被 Vue 实例代理，因为它们可能和 Vue 内置的属性、 API 方法冲突。你可以使用例如 <code>vm.$data._property</code> 的方式访问这些属性。</p>
<p>当一个<strong>组件</strong>被定义， <code>data</code> 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 <code>data</code> 仍然是一个纯粹的对象，则所有的实例将<strong>共享引用</strong>同一个数据对象！通过提供 <code>data</code> 函数，每次创建一个新实例后，我们能够调用 <code>data</code> 函数，从而返回初始数据的一个全新副本数据对象。</p>
<p>如果需要，可以通过将 <code>vm.$data</code> 传入 <code>JSON.parse(JSON.stringify(...))</code> 得到深拷贝的原始数据对象。</p>
</li>
<li><p><strong>示例:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> data = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</div><div class="line"></div><div class="line"><span class="comment">// 直接创建一个实例</span></div><div class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="attr">data</span>: data</div><div class="line">&#125;)</div><div class="line">vm.a <span class="comment">// -&gt; 1</span></div><div class="line">vm.$data === data <span class="comment">// -&gt; true</span></div><div class="line"></div><div class="line"><span class="comment">// Vue.extend() 中 data 必须是函数</span></div><div class="line"><span class="keyword">var</span> Component = Vue.extend(&#123;</div><div class="line">  <span class="attr">data</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p class="tip">注意，<strong>不应该对 <code>data</code> 属性使用箭头函数</strong> (例如<code>data: () =&gt; { return { a: this.myProp }}</code>)。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，<code>this.myProp</code> 将是 undefined。</p>
</li>
<li><p><strong>参考:</strong> <a href="../guide/reactivity.html">深入响应式原理</a></p>
</li>
</ul>
<h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><ul>
<li><p><strong>类型:</strong> <code>Array&lt;string&gt; | Object</code></p>
</li>
<li><p><strong>详细:</strong></p>
<p>props 可以是数组或对象，用于接收来自父组件的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义校验和设置默认值。</p>
</li>
<li><p><strong>示例:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 简单语法</span></div><div class="line">Vue.component(<span class="string">'props-demo-simple'</span>, &#123;</div><div class="line">  <span class="attr">props</span>: [<span class="string">'size'</span>, <span class="string">'myMessage'</span>]</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 对象语法，提供校验</span></div><div class="line">Vue.component(<span class="string">'props-demo-advanced'</span>, &#123;</div><div class="line">  <span class="attr">props</span>: &#123;</div><div class="line">    <span class="comment">// 只检测类型</span></div><div class="line">    height: <span class="built_in">Number</span>,</div><div class="line">    <span class="comment">// 检测类型 + 其他验证</span></div><div class="line">    age: &#123;</div><div class="line">      <span class="attr">type</span>: <span class="built_in">Number</span>,</div><div class="line">      <span class="attr">default</span>: <span class="number">0</span>,</div><div class="line">      <span class="attr">required</span>: <span class="literal">true</span>,</div><div class="line">      <span class="attr">validator</span>: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> value &gt;= <span class="number">0</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p><strong>参考:</strong> <a href="../guide/components.html#Props">Props</a></p>
</li>
</ul>
<h3 id="propsData"><a href="#propsData" class="headerlink" title="propsData"></a>propsData</h3><ul>
<li><p><strong>类型:</strong> <code>{ [key: string]: any }</code></p>
</li>
<li><p><strong>限制:</strong> 只用于 <code>new</code> 创建的实例中。</p>
</li>
<li><p><strong>详细:</strong></p>
<p>创建实例时传递 props。主要作用是方便测试。</p>
</li>
<li><p><strong>示例:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> Comp = Vue.extend(&#123;</div><div class="line">  <span class="attr">props</span>: [<span class="string">'msg'</span>],</div><div class="line">  <span class="attr">template</span>: <span class="string">'&lt;div&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;'</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Comp(&#123;</div><div class="line">  <span class="attr">propsData</span>: &#123;</div><div class="line">    <span class="attr">msg</span>: <span class="string">'hello'</span></div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p><strong>参考:</strong> <a href="../guide/components.html#Props">Props</a></p>
</li>
</ul>
<h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><ul>
<li><p><strong>类型:</strong> <code>{ [key: string]: Function | { get: Function, set: Function } }</code></p>
</li>
<li><p><strong>详细:</strong></p>
<p>计算属性将被混入到 Vue 实例中。所有 getter 和 setter 的 this 上下文自动地绑定为 Vue 实例。</p>
<p class="tip">注意，<strong>不应该使用箭头函数来定义计算属性函数</strong> (例如 <code>aDouble: () =&gt; this.a * 2</code>)。理由是箭头函数绑定了父级作用域的上下文，所以 <code>this</code> 将不会按照期望指向 Vue 实例，<code>this.a</code> 将是 undefined。</p>

<p>计算属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。</p>
</li>
<li><p><strong>示例:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="attr">data</span>: &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;,</div><div class="line">  <span class="attr">computed</span>: &#123;</div><div class="line">    <span class="comment">// 仅读取，值只须为函数</span></div><div class="line">    aDouble: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.a * <span class="number">2</span></div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 读取和设置</span></div><div class="line">    aPlus: &#123;</div><div class="line">      <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="number">1</span></div><div class="line">      &#125;,</div><div class="line">      <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.a = v - <span class="number">1</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line">vm.aPlus   <span class="comment">// -&gt; 2</span></div><div class="line">vm.aPlus = <span class="number">3</span></div><div class="line">vm.a       <span class="comment">// -&gt; 2</span></div><div class="line">vm.aDouble <span class="comment">// -&gt; 4</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>另见:</strong></p>
<ul>
<li><a href="../guide/computed.html">计算属性</a></li>
</ul>
</li>
</ul>
<h3 id="methods"><a href="#methods" class="headerlink" title="methods"></a>methods</h3><ul>
<li><p><strong>类型:</strong> <code>{ [key: string]: Function }</code></p>
</li>
<li><p><strong>详细:</strong></p>
<p>methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 <code>this</code> 自动绑定为 Vue 实例。</p>
<p class="tip">注意，<strong>不应该使用箭头函数来定义 method 函数</strong> (例如 <code>plus: () =&gt; this.a++</code>)。理由是箭头函数绑定了父级作用域的上下文，所以 <code>this</code> 将不会按照期望指向 Vue 实例，<code>this.a</code> 将是 undefined。</p>
</li>
<li><p><strong>示例:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="attr">data</span>: &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;,</div><div class="line">  <span class="attr">methods</span>: &#123;</div><div class="line">    <span class="attr">plus</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">this</span>.a++</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line">vm.plus()</div><div class="line">vm.a <span class="comment">// 2</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>参考:</strong> <a href="../guide/events.html">方法与事件处理器</a></p>
</li>
</ul>
<h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><ul>
<li><p><strong>类型:</strong> <code>{ [key: string]: string | Function | Object }</code></p>
</li>
<li><p><strong>详细:</strong></p>
<p>一个对象，键是需要观察的表达式，值是对应回调函数。值也可以是方法名，或者包含选项的对象。Vue 实例将会在实例化时调用 <code>$watch()</code>，遍历 watch 对象的每一个属性。</p>
</li>
<li><p><strong>示例:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="attr">data</span>: &#123;</div><div class="line">    <span class="attr">a</span>: <span class="number">1</span>,</div><div class="line">    <span class="attr">b</span>: <span class="number">2</span>,</div><div class="line">    <span class="attr">c</span>: <span class="number">3</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">watch</span>: &#123;</div><div class="line">    <span class="attr">a</span>: <span class="function"><span class="keyword">function</span> (<span class="params">val, oldVal</span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'new: %s, old: %s'</span>, val, oldVal)</div><div class="line">    &#125;,</div><div class="line">    <span class="comment">// 方法名</span></div><div class="line">    b: <span class="string">'someMethod'</span>,</div><div class="line">    <span class="comment">// 深度 watcher</span></div><div class="line">    c: &#123;</div><div class="line">      <span class="attr">handler</span>: <span class="function"><span class="keyword">function</span> (<span class="params">val, oldVal</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;,</div><div class="line">      <span class="attr">deep</span>: <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line">vm.a = <span class="number">2</span> <span class="comment">// -&gt; new: 2, old: 1</span></div></pre></td></tr></table></figure>
<p class="tip">注意，<strong>不应该使用箭头函数来定义 watcher 函数</strong> (例如 <code>searchQuery: newValue =&gt; this.updateAutocomplete(newValue)</code>)。理由是箭头函数绑定了父级作用域的上下文，所以 <code>this</code> 将不会按照期望指向 Vue 实例，<code>this.updateAutocomplete</code> 将是 undefined。</p>
</li>
<li><p><strong>参考：</strong> <a href="#vm-watch">实例方法 - vm.$watch</a></p>
</li>
</ul>
<h2 id="选项-DOM"><a href="#选项-DOM" class="headerlink" title="选项 / DOM"></a>选项 / DOM</h2><h3 id="el"><a href="#el" class="headerlink" title="el"></a>el</h3><ul>
<li><p><strong>类型：</strong> <code>string | HTMLElement</code></p>
</li>
<li><p><strong>限制：</strong> 只在由 <code>new</code> 创建的实例中遵守。</p>
</li>
<li><p><strong>详细：</strong></p>
<p>提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。可以是 CSS 选择器，也可以是一个 HTMLElement 实例。</p>
<p>在实例挂载之后， 元素可以用 <code>vm.$el</code> 访问。</p>
<p>如果这个选项在实例化时有作用，实例将立即进入编译过程，否则，需要显式调用 <code>vm.$mount()</code> 手动开启编译。</p>
<p class="tip"> 提供的元素只能作为挂载点。不同于 Vue 1.x，所有的挂载元素会被 Vue 生成的 DOM 替换。因此不推荐挂载root实例到 <code>&lt;html&gt;</code> 或者 <code>&lt;body&gt;</code> 上。</p>
</li>
<li><p><strong>参考：</strong> <a href="../guide/instance.html#生命周期图示">生命周期图示</a></p>
</li>
</ul>
<h3 id="template"><a href="#template" class="headerlink" title="template"></a>template</h3><ul>
<li><p><strong>类型：</strong> <code>string</code></p>
</li>
<li><p><strong>详细：</strong></p>
<p>一个字符串模板作为 Vue 实例的标识使用。模板将会 <strong>替换</strong> 挂载的元素。挂载元素的内容都将被忽略，除非模板的内容有分发 slot。</p>
<p>如果值以 <code>#</code> 开始，则它用作选项符，将使用匹配元素的 innerHTML 作为模板。常用的技巧是用 <code>&lt;script type=&quot;x-template&quot;&gt;</code> 包含模板。</p>
<p class="tip">出于安全考虑，您应该只使用您信任的 Vue 模板。避免使用其他人生成的内容作为您的模板。</p>
</li>
<li><p><strong>参考：</strong></p>
<ul>
<li><a href="../guide/instance.html#生命周期图示">生命周期图示</a></li>
<li><a href="../guide/components.html#使用-Slot-分发内容">内容分发</a></li>
</ul>
</li>
</ul>
<h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><ul>
<li><p><strong>类型：</strong> <code>Function</code></p>
</li>
<li><p><strong>详细：</strong></p>
<p>字符串模板的代替方案，允许你发挥 JavaScript 最大的编程能力。render 函数接收一个 <code>createElement</code> 方法作为第一个参数用来创建 <code>VNode</code>。</p>
<p>如果组件是一个函数组件，Render 函数还会接收一个额外的 <code>context</code> 参数，为没有实例的函数组件提供上下文信息。</p>
</li>
<li><p><strong>参考：</strong></p>
<ul>
<li><a href="../guide/render-function.html">Render 函数</a></li>
</ul>
</li>
</ul>
<h2 id="选项-生命周期钩子"><a href="#选项-生命周期钩子" class="headerlink" title="选项 / 生命周期钩子"></a>选项 / 生命周期钩子</h2><p>所有的生命周期钩子自动绑定 <code>this</code> 上下文到实例中，因此你可以访问数据，对属性和方法进行运算。这意味着 <strong>你不能使用箭头函数来定义一个生命周期方法</strong> (例如 <code>created: () =&gt; this.fetchTodos()</code>)。这是因为箭头函数绑定了父上下文，因此 <code>this</code> 与你期待的 Vue 实例不同， <code>this.fetchTodos</code> 的行为未定义。</p>
<h3 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h3><ul>
<li><p><strong>类型：</strong> <code>Function</code></p>
</li>
<li><p><strong>详细：</strong></p>
<p>在实例初始化之后，数据观测(data observer) 和 event/watcher 事件配置之前被调用。</p>
</li>
<li><p><strong>参考：</strong> <a href="../guide/instance.html#生命周期图示">生命周期图示</a></p>
</li>
</ul>
<h3 id="created"><a href="#created" class="headerlink" title="created"></a>created</h3><ul>
<li><p><strong>类型：</strong> <code>Function</code></p>
</li>
<li><p><strong>详细：</strong></p>
<p>实例已经创建完成之后被调用。在这一步，实例已完成以下的配置：数据观测(data observer)，属性和方法的运算， watch/event 事件回调。然而，挂载阶段还没开始，<code>$el</code> 属性目前不可见。</p>
</li>
<li><p><strong>参考：</strong> <a href="../guide/instance.html#生命周期图示">生命周期图示</a></p>
</li>
</ul>
<h3 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h3><ul>
<li><p><strong>类型：</strong> <code>Function</code></p>
</li>
<li><p><strong>详细：</strong></p>
<p>在挂载开始之前被调用：相关的 <code>render</code> 函数首次被调用。</p>
<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
</li>
<li><p><strong>参考：</strong> <a href="../guide/instance.html#生命周期图示">生命周期图示</a></p>
</li>
</ul>
<h3 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h3><ul>
<li><p><strong>类型：</strong> <code>Function</code></p>
</li>
<li><p><strong>详细：</strong></p>
<p><code>el</code> 被新创建的 <code>vm.$el</code> 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 <code>mounted</code> 被调用时 <code>vm.$el</code> 也在文档内。</p>
<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
</li>
<li><p><strong>参考：</strong> <a href="../guide/instance.html#生命周期图示">生命周期图示</a></p>
</li>
</ul>
<h3 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a>beforeUpdate</h3><ul>
<li><p><strong>类型：</strong> <code>Function</code></p>
</li>
<li><p><strong>详细：</strong></p>
<p>数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。</p>
<p>你可以在这个钩子中进一步地更改状态，这不会触发附加的重渲染过程。</p>
<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
</li>
<li><p><strong>参考：</strong> <a href="../guide/instance.html#生命周期图示">生命周期图示</a></p>
</li>
</ul>
<h3 id="updated"><a href="#updated" class="headerlink" title="updated"></a>updated</h3><ul>
<li><p><strong>类型：</strong> <code>Function</code></p>
</li>
<li><p><strong>详细：</strong></p>
<p>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。</p>
<p>当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态，因为这可能会导致更新无限循环。</p>
<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
</li>
<li><p><strong>参考：</strong> <a href="../guide/instance.html#生命周期图示">生命周期图示</a></p>
</li>
</ul>
<h3 id="activated"><a href="#activated" class="headerlink" title="activated"></a>activated</h3><ul>
<li><p><strong>类型：</strong> <code>Function</code></p>
</li>
<li><p><strong>详细：</strong></p>
<p>keep-alive 组件激活时调用。</p>
<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
</li>
<li><p><strong>参考：</strong></p>
<ul>
<li><a href="#keep-alive">构建组件 - keep-alive</a></li>
<li><a href="../guide/components.html#keep-alive">动态组件 - keep-alive</a></li>
</ul>
</li>
</ul>
<h3 id="deactivated"><a href="#deactivated" class="headerlink" title="deactivated"></a>deactivated</h3><ul>
<li><p><strong>类型：</strong> <code>Function</code></p>
</li>
<li><p><strong>详细：</strong></p>
<p>keep-alive 组件停用时调用。</p>
<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
</li>
<li><p><strong>参考：</strong></p>
<ul>
<li><a href="#keep-alive">构建组件 - keep-alive</a></li>
<li><a href="../guide/components.html#keep-alive">动态组件 - keep-alive</a></li>
</ul>
</li>
</ul>
<h3 id="beforeDestroy"><a href="#beforeDestroy" class="headerlink" title="beforeDestroy"></a>beforeDestroy</h3><ul>
<li><p><strong>类型：</strong> <code>Function</code></p>
</li>
<li><p><strong>详细：</strong></p>
<p>实例销毁之前调用。在这一步，实例仍然完全可用。</p>
<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
</li>
<li><p><strong>参考：</strong> <a href="../guide/instance.html#生命周期图示">生命周期图示</a></p>
</li>
</ul>
<h3 id="destroyed"><a href="#destroyed" class="headerlink" title="destroyed"></a>destroyed</h3><ul>
<li><p><strong>类型：</strong> <code>Function</code></p>
</li>
<li><p><strong>详细：</strong></p>
<p>Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</p>
<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
</li>
<li><p><strong>参考：</strong> <a href="../guide/instance.html#生命周期图示">生命周期图示</a></p>
</li>
</ul>
<h2 id="选项-资源"><a href="#选项-资源" class="headerlink" title="选项 / 资源"></a>选项 / 资源</h2><h3 id="directives"><a href="#directives" class="headerlink" title="directives"></a>directives</h3><ul>
<li><p><strong>类型:</strong> <code>Object</code></p>
</li>
<li><p><strong>详细:</strong></p>
</li>
</ul>
<p>包含 Vue 实例可用指令的哈希表。</p>
<ul>
<li><strong>参考：</strong><ul>
<li><a href="../guide/custom-directive.html">自定义指令</a></li>
<li><a href="../guide/components.html#Assets-Naming-Convention">资源命名约定</a></li>
</ul>
</li>
</ul>
<h3 id="filters"><a href="#filters" class="headerlink" title="filters"></a>filters</h3><ul>
<li><p><strong>类型:</strong> <code>Object</code></p>
</li>
<li><p><strong>详细:</strong></p>
</li>
</ul>
<p>包含 Vue 实例可用过滤器的哈希表。</p>
<ul>
<li><strong>另见:</strong><ul>
<li><a href="#Vue-filter"><code>Vue.filter</code></a></li>
</ul>
</li>
</ul>
<h3 id="components"><a href="#components" class="headerlink" title="components"></a>components</h3><ul>
<li><p><strong>类型:</strong> <code>Object</code></p>
</li>
<li><p><strong>详细:</strong></p>
</li>
</ul>
<p>包含 Vue 实例可用组件的哈希表。</p>
<ul>
<li><strong>参考：</strong><ul>
<li><a href="../guide/components.html">组件</a></li>
</ul>
</li>
</ul>
<h2 id="选项-杂项"><a href="#选项-杂项" class="headerlink" title="选项 / 杂项"></a>选项 / 杂项</h2><h3 id="parent"><a href="#parent" class="headerlink" title="parent"></a>parent</h3><ul>
<li><p><strong>类型:</strong> <code>Vue instance</code></p>
</li>
<li><p><strong>详细:</strong></p>
<p>指定已创建的实例之父实例，在两者之间建立父子关系。子实例可以用 <code>this.$parent</code> 访问父实例，子实例被推入父实例的 <code>$children</code> 数组中。</p>
<p class="tip">同时使用 <code>$parent</code> 和 <code>$children</code> 有冲突 - 他们作为同一个入口 。更推荐用 props 和 events 实现父子组件通信</p>

</li>
</ul>
<h3 id="mixins"><a href="#mixins" class="headerlink" title="mixins"></a>mixins</h3><ul>
<li><p><strong>类型:</strong> <code>Array&lt;Object&gt;</code></p>
</li>
<li><p><strong>详细:</strong></p>
<p><code>mixins</code> 选项接受一个混合对象的数组。这些混合实例对象可以像正常的实例对象一样包含选项,他们将在 <code>Vue.extend()</code> 里最终选择使用相同的选项合并逻辑合并。举例：如果你混合包含一个钩子而创建组件本身也有一个,两个函数将被调用。<br>Mixin钩子按照传入顺序依次调用,并在调用组件自身的钩子之前被调用。</p>
</li>
<li><p><strong>示例:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> mixin = &#123;</div><div class="line">  <span class="attr">created</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">1</span>) &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="attr">created</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="number">2</span>) &#125;,</div><div class="line">  <span class="attr">mixins</span>: [mixin]</div><div class="line">&#125;)</div><div class="line"><span class="comment">// -&gt; 1</span></div><div class="line"><span class="comment">// -&gt; 2</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>参考：</strong> <a href="../guide/mixins.html">混合</a></p>
</li>
</ul>
<h3 id="name"><a href="#name" class="headerlink" title="name"></a>name</h3><ul>
<li><p><strong>类型:</strong> <code>string</code></p>
</li>
<li><p><strong>限制:</strong> 只有作为组件选项时起作用。</p>
</li>
<li><p><strong>详细:</strong></p>
<p>允许组件模板递归地调用自身。注意，组件在全局用 <code>Vue.component()</code> 注册时，全局 ID 自动作为组件的 name。</p>
<p>指定 <code>name</code> 选项的另一个好处是便于调试。有名字的组件有更友好的警告信息。另外，当在有 <a href="https://github.com/vuejs/vue-devtools" target="_blank" rel="external">vue-devtools</a>, 未命名组件将显示成 <code>&lt;AnonymousComponent&gt;</code>, 这很没有语义。通过提供 <code>name</code> 选项，可以获得更有语义信息的组件树。</p>
</li>
</ul>
<h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h3><ul>
<li><p><strong>类型:</strong> <code>Object | Function</code></p>
</li>
<li><p><strong>详细:</strong></p>
<p>允许声明扩展另一个组件(可以是一个简单的选项对象或构造函数),而无需使用 <code>Vue.extend</code>。这主要是为了便于扩展单文件组件。</p>
<p>这和 <code>mixins</code> 类似，区别在于，组件自身的选项会比要扩展的源组件具有更高的优先级。</p>
</li>
<li><p><strong>示例:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> CompA = &#123; ... &#125;</div><div class="line"></div><div class="line"><span class="comment">// 在没有调用 Vue.extend 时候继承 CompA</span></div><div class="line"><span class="keyword">var</span> CompB = &#123;</div><div class="line">  <span class="attr">extends</span>: CompA,</div><div class="line">  ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="delimiters"><a href="#delimiters" class="headerlink" title="delimiters"></a>delimiters</h3><ul>
<li><p><strong>类型:</strong> <code>Array&lt;string&gt;</code></p>
</li>
<li><p><strong>默认值:</strong> <code>["{{", "}}"]</code></p>
</li>
<li><p><strong>详细:</strong></p>
<p>改变纯文本插入分隔符。 <strong>这个选择只有在独立构建时才有用。</strong></p>
</li>
</ul>
<ul>
<li><p><strong>示例:</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="attr">delimiters</span>: [<span class="string">'$&#123;'</span>, <span class="string">'&#125;'</span>]</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 分隔符变成了 ES6 模板字符串的风格</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="functional"><a href="#functional" class="headerlink" title="functional"></a>functional</h3><ul>
<li><p><strong>类型:</strong> <code>boolean</code></p>
</li>
<li><p><strong>详细:</strong></p>
<p>使组件无状态（没有 <code>data</code> ）和无实例（没有 <code>this</code> 上下文）。他们用一个简单的 <code>render</code> 函数返回虚拟节点使他们更容易渲染。</p>
</li>
<li><p><strong>参考：
</strong> <a href="../guide/render-function.html#函数化组件">函数式组件</a></p>
</li>
</ul>
<h2 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h2><h3 id="vm-data"><a href="#vm-data" class="headerlink" title="vm.$data"></a>vm.$data</h3><ul>
<li><p><strong>类型:</strong> <code>Object</code></p>
</li>
<li><p><strong>详细:</strong></p>
<p>Vue 实例观察的数据对象。Vue 实例代理了对其 data 对象属性的访问。</p>
</li>
<li><p><strong>另见:</strong> <a href="#data">选项 - data</a></p>
</li>
</ul>
<h3 id="vm-el"><a href="#vm-el" class="headerlink" title="vm.$el"></a>vm.$el</h3><ul>
<li><p><strong>类型:</strong> <code>HTMLElement</code></p>
</li>
<li><p><strong>只读</strong></p>
</li>
<li><p><strong>详细:</strong></p>
<p>Vue 实例使用的根 DOM 元素。</p>
</li>
</ul>
<h3 id="vm-options"><a href="#vm-options" class="headerlink" title="vm.$options"></a>vm.$options</h3><ul>
<li><p><strong>类型:</strong> <code>Object</code></p>
</li>
<li><p><strong>只读</strong></p>
</li>
<li><p><strong>详细:</strong></p>
<p>用于当前 Vue 实例的初始化选项。需要在选项中包含自定义属性时会有用处：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="attr">customOption</span>: <span class="string">'foo'</span>,</div><div class="line">  <span class="attr">created</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.$options.customOption) <span class="comment">// -&gt; 'foo'</span></div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="vm-parent"><a href="#vm-parent" class="headerlink" title="vm.$parent"></a>vm.$parent</h3><ul>
<li><p><strong>类型:</strong> <code>Vue instance</code></p>
</li>
<li><p><strong>只读</strong></p>
</li>
<li><p><strong>详细:</strong></p>
<p>父实例，如果当前实例有的话。</p>
</li>
</ul>
<h3 id="vm-root"><a href="#vm-root" class="headerlink" title="vm.$root"></a>vm.$root</h3><ul>
<li><p><strong>类型:</strong> <code>Vue instance</code></p>
</li>
<li><p><strong>只读</strong></p>
</li>
<li><p><strong>详细:</strong></p>
<p>当前组件树的根 Vue 实例。如果当前实例没有父实例，此实例将会是其自已。</p>
</li>
</ul>
<h3 id="vm-children"><a href="#vm-children" class="headerlink" title="vm.$children"></a>vm.$children</h3><ul>
<li><p><strong>类型:</strong> <code>Array&lt;Vue instance&gt;</code></p>
</li>
<li><p><strong>只读</strong></p>
</li>
<li><p><strong>详细:</strong></p>
<p>当前实例的直接子组件。<strong>需要注意 <code>$children</code> 并不保证顺序，也不是响应式的。</strong>如果你发现自己正在尝试使用 <code>$children</code> 来进行数据绑定，考虑使用一个数组配合 <code>v-for</code> 来生成子组件，并且使用 Array 作为真正的来源。</p>
</li>
</ul>
<h3 id="vm-slots"><a href="#vm-slots" class="headerlink" title="vm.$slots"></a>vm.$slots</h3><ul>
<li><p><strong>类型：</strong> <code>{ [name: string]: ?Array&lt;VNode&gt; }</code></p>
</li>
<li><p><strong>只读</strong></p>
</li>
<li><p><strong>详细:</strong></p>
<p>用来访问被 <a href="../guide/components.html#使用-Slot-分发内容">slot 分发</a>的内容。每个<a href="../guide/components.html#具名-Slot">具名 slot</a> 有其相应的属性（例如：<code>slot=&quot;foo&quot;</code> 中的内容将会在 <code>vm.$slots.foo</code> 中被找到）。<code>default</code> 属性包括了所有没有被包含在具名 slot 中的节点。</p>
<p>在使用 <a href="../guide/render-function.html">render 函数</a>书写一个组件时，访问 <code>vm.$slots</code> 最有帮助。</p>
</li>
<li><p><strong>示例:</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">blog-post</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">slot</span>=<span class="string">"header"</span>&gt;</span></div><div class="line">    About Me</div><div class="line">  <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Here's some page content, which will be included in vm.$slots.default, because it's not inside a named slot.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">slot</span>=<span class="string">"footer"</span>&gt;</span></div><div class="line">    Copyright 2016 Evan You</div><div class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>If I have some content down here, it will also be included in vm.$slots.default.<span class="tag">&lt;/<span class="name">p</span>&gt;</span>.</div><div class="line"><span class="tag">&lt;/<span class="name">blog-post</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">Vue.component(<span class="string">'blog-post'</span>, &#123;</div><div class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> header = <span class="keyword">this</span>.$slots.header</div><div class="line">    <span class="keyword">var</span> body   = <span class="keyword">this</span>.$slots.default</div><div class="line">    <span class="keyword">var</span> footer = <span class="keyword">this</span>.$slots.footer</div><div class="line">    <span class="keyword">return</span> createElement(<span class="string">'div'</span>, [</div><div class="line">      createElement(<span class="string">'header'</span>, header),</div><div class="line">      createElement(<span class="string">'main'</span>, body),</div><div class="line">      createElement(<span class="string">'footer'</span>, footer)</div><div class="line">    ])</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p><strong>参考：</strong></p>
<ul>
<li><a href="#slot-1"><code>&lt;slot&gt;</code> 组件</a></li>
<li><a href="../guide/components.html#使用-Slot-分发内容">使用 Slots 进行内容分发</a></li>
<li><a href="../guide/render-function.html#Slots">Render 函数</a></li>
</ul>
</li>
</ul>
<h3 id="vm-scopedSlots"><a href="#vm-scopedSlots" class="headerlink" title="vm.$scopedSlots"></a>vm.$scopedSlots</h3><blockquote>
<p>2.1.0新增</p>
</blockquote>
<ul>
<li><p><strong>类型：</strong> <code>{ [name: string]: props =&gt; VNode | Array&lt;VNode&gt; }</code></p>
</li>
<li><p><strong>只读</strong></p>
</li>
<li><p><strong>详细：</strong></p>
<p>Used to programmatically access <a href="../guide/components.html#Scoped-Slots">scoped slots</a>. For each slot, including the <code>default</code> one, the object contains a corresponding function that returns VNodes.</p>
<p>Accessing <code>vm.$scopedSlots</code> is most useful when writing a component with a <a href="../guide/render-function.html">render function</a>.</p>
</li>
<li><p><strong>参考：</strong></p>
<ul>
<li><a href="#slot-1"><code>&lt;slot&gt;</code> 组件</a></li>
<li><a href="../guide/components.html#Scoped-Slots">Scoped Slots</a></li>
<li><a href="../guide/render-function.html#Slots">Render 函数</a></li>
</ul>
</li>
</ul>
<h3 id="vm-refs"><a href="#vm-refs" class="headerlink" title="vm.$refs"></a>vm.$refs</h3><ul>
<li><p><strong>类型：</strong> <code>Object</code></p>
</li>
<li><p><strong>只读</strong></p>
</li>
<li><p><strong>详细：</strong></p>
<p>一个对象，其中包含了所有拥有 <code>ref</code> 注册的子组件。</p>
</li>
<li><p><strong>另见：</strong></p>
<ul>
<li><a href="../guide/components.html#子组件索引">子组件引用</a></li>
<li><a href="#ref">ref</a></li>
</ul>
</li>
</ul>
<h3 id="vm-isServer"><a href="#vm-isServer" class="headerlink" title="vm.$isServer"></a>vm.$isServer</h3><ul>
<li><p><strong>类型：</strong> <code>boolean</code></p>
</li>
<li><p><strong>只读</strong></p>
</li>
<li><p><strong>详细：</strong></p>
<p>当前 Vue 实例是否运行于服务器。</p>
</li>
<li><p><strong>参考：</strong> <a href="../guide/ssr.html">服务端渲染</a></p>
</li>
</ul>
<h2 id="实例方法-数据"><a href="#实例方法-数据" class="headerlink" title="实例方法 / 数据"></a>实例方法 / 数据</h2><h3 id="vm-watch">vm.$watch( expOrFn, callback, [options] )</h3>

<ul>
<li><p><strong>参数：</strong></p>
<ul>
<li><code>{string | Function} expOrFn</code></li>
<li><code>{Function} callback</code></li>
<li><code>{Object} [options]</code><ul>
<li><code>{boolean} deep</code></li>
<li><code>{boolean} immediate</code></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回值：</strong> <code>{Function} unwatch</code></p>
</li>
<li><p><strong>用法：</strong></p>
<p>观察 Vue 实例变化的一个表达式或计算属性函数。回调函数得到的参数为新值和旧值。表达式只接受监督的键路径。对于更复杂的表达式，用一个函数取代。</p>
<p class="tip">注意：在变异（不是替换）对象或数组时，旧值将与新值相同，因为它们的引用指向同一个对象/数组。Vue 不会保留变异之前值的副本。</p>
</li>
<li><p><strong>示例：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 键路径</span></div><div class="line">vm.$watch(<span class="string">'a.b.c'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">newVal, oldVal</span>) </span>&#123;</div><div class="line">  <span class="comment">// 做点什么</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 函数</span></div><div class="line">vm.$watch(</div><div class="line">  <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="keyword">this</span>.b</div><div class="line">  &#125;,</div><div class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">newVal, oldVal</span>) </span>&#123;</div><div class="line">    <span class="comment">// 做点什么</span></div><div class="line">  &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<p><code>vm.$watch</code> 返回一个取消观察函数，用来停止触发回调：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> unwatch = vm.$watch(<span class="string">'a'</span>, cb)</div><div class="line"><span class="comment">// 之后取消观察</span></div><div class="line">unwatch()</div></pre></td></tr></table></figure>
</li>
<li><p><strong>选项：deep</strong></p>
<p>为了发现对象内部值的变化，可以在选项参数中指定 <code>deep: true</code> 。注意监听数组的变动不需要这么做。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">vm.$watch(<span class="string">'someObject'</span>, callback, &#123;</div><div class="line">  <span class="attr">deep</span>: <span class="literal">true</span></div><div class="line">&#125;)</div><div class="line">vm.someObject.nestedValue = <span class="number">123</span></div><div class="line"><span class="comment">// callback is fired</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>选项：immediate</strong></p>
<p>在选项参数中指定 <code>immediate: true</code> 将立即以表达式的当前值触发回调：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">vm.$watch(<span class="string">'a'</span>, callback, &#123;</div><div class="line">  <span class="attr">immediate</span>: <span class="literal">true</span></div><div class="line">&#125;)</div><div class="line"><span class="comment">// 立即以 `a` 的当前值触发回调</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="vm-set">vm.$set( object, key, value )</h3>

<ul>
<li><p><strong>参数：</strong></p>
<ul>
<li><code>{Object} object</code></li>
<li><code>{string} key</code></li>
<li><code>{any} value</code></li>
</ul>
</li>
<li><p><strong>返回值：</strong> 设置的值.</p>
</li>
<li><p><strong>用法：</strong></p>
<p>这是全局 <code>Vue.set</code> 的<strong>别名</strong>。</p>
</li>
<li><p><strong>另见：</strong> <a href="#Vue-set">Vue.set</a></p>
</li>
</ul>
<h3 id="vm-delete">vm.$delete( object, key )</h3>

<ul>
<li><p><strong>参数：</strong></p>
<ul>
<li><code>{Object} object</code></li>
<li><code>{string} key</code></li>
</ul>
</li>
<li><p><strong>用法：</strong></p>
<p>这是全局 <code>Vue.delete</code> 的<strong>别名</strong>。</p>
</li>
<li><p><strong>另见：</strong> <a href="#Vue-delete">Vue.delete</a></p>
</li>
</ul>
<h2 id="实例方法-事件"><a href="#实例方法-事件" class="headerlink" title="实例方法/事件"></a>实例方法/事件</h2><h3 id="vm-on">vm.$on( event, callback )</h3>

<ul>
<li><p><strong>参数：</strong></p>
<ul>
<li><code>{string} event</code></li>
<li><code>{Function} callback</code></li>
</ul>
</li>
<li><p><strong>用法：</strong></p>
<p>监听当前实例上的自定义事件。事件可以由<code>vm.$emit</code>触发。回调函数会接收所有传入事件触发函数的额外参数。</p>
</li>
<li><p><strong>示例：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line">vm.$on(<span class="string">'test'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">msg</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(msg)</div><div class="line">&#125;)</div><div class="line">vm.$emit(<span class="string">'test'</span>, <span class="string">'hi'</span>)</div><div class="line"><span class="comment">// -&gt; "hi"</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="vm-once">vm.$once( event, callback )</h3>

<ul>
<li><p><strong>参数：</strong></p>
<ul>
<li><code>{string} event</code></li>
<li><code>{Function} callback</code></li>
</ul>
</li>
<li><p><strong>用法：</strong></p>
<p>监听一个自定义事件，但是只触发一次，在第一次触发之后移除监听器。</p>
</li>
</ul>
<h3 id="vm-off">vm.$off( [event, callback] )</h3>

<ul>
<li><p><strong>参数：</strong></p>
<ul>
<li><code>{string} [event]</code></li>
<li><code>{Function} [callback]</code></li>
</ul>
</li>
<li><p><strong>用法：</strong></p>
<p>移除事件监听器。</p>
<ul>
<li><p>如果没有提供参数，则移除所有的事件监听器；</p>
</li>
<li><p>如果只提供了事件，则移除该事件所有的监听器；</p>
</li>
<li><p>如果同时提供了事件与回调，则只移除这个回调的监听器。</p>
</li>
</ul>
</li>
</ul>
<h3 id="vm-emit">vm.$emit( event, […args] )</h3>

<ul>
<li><p><strong>参数：</strong></p>
<ul>
<li><code>{string} event</code></li>
<li><code>[...args]</code></li>
</ul>
<p>触发当前实例上的事件。附加参数都会传给监听器回调。</p>
</li>
</ul>
<h2 id="实例方法-生命周期"><a href="#实例方法-生命周期" class="headerlink" title="实例方法 / 生命周期"></a>实例方法 / 生命周期</h2><h3 id="vm-mount">vm.$mount( [elementOrSelector] )</h3>

<ul>
<li><p><strong>参数：</strong></p>
<ul>
<li><code>{Element | string} [elementOrSelector]</code></li>
<li><code>{boolean} [hydrating]</code></li>
</ul>
</li>
<li><p><strong>返回值：</strong> <code>vm</code> - 实例自身</p>
</li>
<li><p><strong>用法：</strong></p>
<p>如果 Vue 实例在实例化时没有收到 el 选项，则它处于“未挂载”状态，没有关联的 DOM 元素。可以使用 <code>vm.$mount()</code> 手动地挂载一个未挂载的实例。</p>
<p>如果没有提供 <code>elementOrSelector</code> 参数，模板将被渲染为文档之外的的元素，并且你必须使用原生DOM API把它插入文档中。</p>
<p>这个方法返回实例自身，因而可以链式调用其它实例方法。</p>
</li>
<li><p><strong>示例：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> MyComponent = Vue.extend(&#123;</div><div class="line">  <span class="attr">template</span>: <span class="string">'&lt;div&gt;Hello!&lt;/div&gt;'</span></div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 创建并挂载到 #app (会替换 #app)</span></div><div class="line"><span class="keyword">new</span> MyComponent().$mount(<span class="string">'#app'</span>)</div><div class="line"></div><div class="line"><span class="comment">// 同上</span></div><div class="line"><span class="keyword">new</span> MyComponent(&#123; <span class="attr">el</span>: <span class="string">'#app'</span> &#125;)</div><div class="line"></div><div class="line"><span class="comment">// 或者，在文档之外渲染并且随后挂载</span></div><div class="line"><span class="keyword">var</span> component = <span class="keyword">new</span> MyComponent().$mount()</div><div class="line"><span class="built_in">document</span>.getElementById(<span class="string">'app'</span>).appendChild(component.$el)</div></pre></td></tr></table></figure>
</li>
<li><p><strong>参考：</strong></p>
<ul>
<li><a href="../guide/instance.html#生命周期图示">生命周期图示</a></li>
<li><a href="../guide/ssr.html">服务端渲染</a></li>
</ul>
</li>
</ul>
<h3 id="vm-forceUpdate">vm.$forceUpdate()</h3>

<ul>
<li><p><strong>示例：</strong></p>
<p>迫使Vue实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。</p>
</li>
</ul>
<h3 id="vm-nextTick">vm.$nextTick( [callback] )</h3>

<ul>
<li><p><strong>参数：</strong></p>
<ul>
<li><code>{Function} [callback]</code></li>
</ul>
</li>
<li><p><strong>用法：</strong></p>
<p>将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 Vue.nextTick 一样，不同的是回调的 <code>this</code> 自动绑定到调用它的实例上。</p>
</li>
</ul>
<blockquote>
<p>2.1.0新增：如果没有提供回调且支持 promise 的环境中返回 promise。</p>
</blockquote>
<ul>
<li><p><strong>示例：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">  methods: &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    example: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="comment">// 修改数据</span></div><div class="line">      <span class="keyword">this</span>.message = <span class="string">'changed'</span></div><div class="line">      <span class="comment">// DOM 还没有更新</span></div><div class="line">      <span class="keyword">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// DOM 现在更新了</span></div><div class="line">        <span class="comment">// `this` 绑定到当前实例</span></div><div class="line">        <span class="keyword">this</span>.doSomethingElse()</div><div class="line">      &#125;)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
<li><p><strong>参考：</strong></p>
<ul>
<li><a href="#Vue-nextTick">Vue.nextTick</a></li>
<li><a href="../guide/reactivity.html#异步更新队列">异步更新队列</a></li>
</ul>
</li>
</ul>
<h3 id="vm-destroy">vm.$destroy()</h3>

<ul>
<li><p><strong>用法：</strong></p>
<p>完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令及事件监听器。</p>
<p>触发 <code>beforeDestroy</code> 和 <code>destroyed</code> 的钩子。</p>
<p class="tip">在大多数场景中你不应该调用这个方法。最好使用 <code>v-if</code> 和 <code>v-for</code> 指令以数据驱动的方式控制子组件的生命周期。</p>
</li>
<li><p><strong>参考：</strong> <a href="../guide/instance.html#生命周期图示">生命周期图示</a></p>
</li>
</ul>
<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><h3 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h3><ul>
<li><p><strong>类型：</strong> <code>string</code></p>
</li>
<li><p><strong>详细：</strong></p>
<p>更新元素的 <code>textContent</code>。如果要更新部分的 <code>textContent</code> ，需要使用 <code>{{ Mustache }}</code> 插值。</p>
</li>
<li><p><strong>示例：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-text</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 和下面的一样 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>参考：</strong> <a href="../guide/syntax.html#插值">数据绑定语法 - 插值</a></p>
</li>
</ul>
<h3 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h3><ul>
<li><p><strong>类型：</strong> <code>string</code></p>
</li>
<li><p><strong>详细：</strong></p>
</li>
</ul>
<p>  更新元素的 <code>innerHTML</code> 。<strong>注意：内容按普通 HTML 插入 - 不会作为 Vue 模板进行编译</strong> 。如果试图使用 <code>v-html</code> 组合模板,可以重新考虑是否通过使用组件来替代。</p>
  <p class="tip">在网站上动态渲染任意 HTML 是非常危险的，因为容易导致 <a href="https://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank" rel="external">XSS 攻击</a>。只在可信内容上使用 <code>v-html</code>，<strong>永不</strong>用在用户提交的内容上。</p>

<ul>
<li><p><strong>示例：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-html</span>=<span class="string">"html"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>参考：</strong> <a href="../guide/syntax.html#Raw-HTML">数据绑定语法 - 插值</a></p>
</li>
</ul>
<h3 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h3><ul>
<li><p><strong>类型：</strong> <code>any</code></p>
</li>
<li><p><strong>用法：</strong></p>
<p>根据表达式之真假值，切换元素的 <code>display</code> CSS 属性。</p>
<p>当条件变化时该指令触发过渡效果。</p>
</li>
<li><p><strong>参考：</strong> <a href="../guide/conditional.html#v-show">条件渲染 - v-show</a></p>
</li>
</ul>
<h3 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h3><ul>
<li><p><strong>类型：</strong> <code>any</code></p>
</li>
<li><p><strong>用法：</strong></p>
<p>根据表达式的值的真假条件渲染元素。在切换时元素及它的数据绑定 / 组件被销毁并重建。如果元素是 <code>&lt;template&gt;</code> ，将提出它的内容作为条件块。</p>
<p>当条件变化时该指令触发过渡效果。</p>
</li>
<li><p><strong>参考：</strong> <a href="../guide/conditional.html">条件渲染 - v-if</a></p>
</li>
</ul>
<h3 id="v-else"><a href="#v-else" class="headerlink" title="v-else"></a>v-else</h3><ul>
<li><p><strong>不需要表达式</strong></p>
</li>
<li><p><strong>限制：</strong> 前一兄弟元素必须有 <code>v-if</code> 或 <code>v-else-if</code>。</p>
</li>
<li><p><strong>用法：</strong></p>
<p>为 <code>v-if</code> 或者 <code>v-else-if</code> 添加 “else 块”。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"Math.random() &gt; 0.5"</span>&gt;</span></div><div class="line">  Now you see me</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></div><div class="line">  Now you don't</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>参考：</strong></p>
<ul>
<li><a href="../guide/conditional.html#v-else">条件渲染 - v-else</a></li>
</ul>
</li>
</ul>
<h3 id="v-else-if"><a href="#v-else-if" class="headerlink" title="v-else-if"></a>v-else-if</h3><blockquote>
<p>2.1.0新增</p>
</blockquote>
<ul>
<li><p><strong>Expects:</strong> <code>any</code></p>
</li>
<li><p><strong>Restriction:</strong> previous sibling element must have <code>v-if</code> or <code>v-else-if</code>.</p>
</li>
<li><p><strong>Usage:</strong></p>
<p>Denote the “else if block” for <code>v-if</code>. Can be chained.</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"type === 'A'"</span>&gt;</span></div><div class="line">  A</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">"type === 'B'"</span>&gt;</span></div><div class="line">  B</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">"type === 'C'"</span>&gt;</span></div><div class="line">  C</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></div><div class="line">  Not A/B/C</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>See also:</strong> <a href="../guide/conditional.html#v-else-if">条件渲染 - v-else-if</a></p>
</li>
</ul>
<h3 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h3><ul>
<li><p><strong>类型：</strong> <code>Array | Object | number | string</code></p>
</li>
<li><p><strong>用法：</strong></p>
<p>基于源数据多次渲染元素或模板块。此指令之值，必须使用特定语法 <code>alias in expression</code> ，为当前遍历的元素提供别名：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span>&gt;</span></div><div class="line">  &#123;&#123; item.text &#125;&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>另外也可以为数组索引指定别名（或者用于对象的键）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(item, index) in items"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(val, key) in object"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"(val, key, index) in object"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p><code>v-for</code> 默认行为试着不改变整体，而是替换元素。迫使其重新排序的元素,您需要提供一个 <code>key</code> 的特殊属性:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span></div><div class="line">  &#123;&#123; item.text &#125;&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p><code>v-for</code> 的详细用法可以通过以下链接查看教程详细说明。</p>
</li>
<li><p><strong>参考：</strong></p>
<ul>
<li><a href="../guide/list.html">列表渲染</a></li>
<li><a href="../guide/list.html#key">key</a></li>
</ul>
</li>
</ul>
<h3 id="v-on"><a href="#v-on" class="headerlink" title="v-on"></a>v-on</h3><ul>
<li><p><strong>缩写：</strong> <code>@</code></p>
</li>
<li><p><strong>类型：</strong> <code>Function | Inline Statement</code></p>
</li>
<li><p><strong>参数：</strong> <code>event (required)</code></p>
</li>
<li><p><strong>修饰符：</strong></p>
<ul>
<li><code>.stop</code> - 调用 <code>event.stopPropagation()</code>。</li>
<li><code>.prevent</code> - 调用 <code>event.preventDefault()</code>。</li>
<li><code>.capture</code> - 添加事件侦听器时使用 capture 模式。</li>
<li><code>.self</code> - 只当事件是从侦听器绑定的元素本身触发时才触发回调。</li>
<li><code>.{keyCode | keyAlias}</code> - 只当事件是从侦听器绑定的元素本身触发时才触发回调。</li>
<li><code>.native</code> - 监听组件根元素的原生事件。</li>
</ul>
</li>
<li><p><strong>用法：</strong></p>
<p>绑定事件监听器。事件类型由参数指定。表达式可以是一个方法的名字或一个内联语句，如果没有修饰符也可以省略。</p>
<p>用在普通元素上时，只能监听 <strong>原生 DOM 事件</strong>。用在自定义元素组件上时，也可以监听子组件触发的<strong>自定义事件</strong>。</p>
<p>在监听原生 DOM 事件时，方法以事件为唯一的参数。如果使用内联语句，语句可以访问一个 <code>$event</code> 属性： <code>v-on:click=&quot;handle(&#39;ok&#39;, $event)&quot;</code>。</p>
</li>
<li><p><strong>示例：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 方法处理器 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 内联语句 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">"doThat('hello', $event)"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 停止冒泡 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 阻止默认行为 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.prevent</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 阻止默认行为，没有表达式 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">form</span> @<span class="attr">submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!--  串联修饰符 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop.prevent</span>=<span class="string">"doThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 键修饰符，键别名 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.enter</span>=<span class="string">"onEnter"</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 键修饰符，键代码 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> @<span class="attr">keyup.13</span>=<span class="string">"onEnter"</span>&gt;</span></div></pre></td></tr></table></figure>
<p>在子组件上监听自定义事件（当子组件触发 “my-event” 时将调用事件处理器）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">my-component</span> @<span class="attr">my-event</span>=<span class="string">"handleThis"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 内联语句 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">my-component</span> @<span class="attr">my-event</span>=<span class="string">"handleThis(123, $event)"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 组件中的原生事件 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">my-component</span> @<span class="attr">click.native</span>=<span class="string">"onClick"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>参考：</strong></p>
<ul>
<li><a href="../guide/events.html">方法与事件处理器</a></li>
<li><a href="../guide/components.html#自定义事件">组件 - 自定义事件</a></li>
</ul>
</li>
</ul>
<h3 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h3><ul>
<li><p><strong>缩写：</strong> <code>:</code></p>
</li>
<li><p><strong>类型：</strong> <code>any (with argument) | Object (without argument)</code></p>
</li>
<li><p><strong>参数：</strong> <code>attrOrProp (optional)</code></p>
</li>
<li><p><strong>修饰符：</strong></p>
<ul>
<li><code>.prop</code> - 被用于绑定 DOM 属性。(<a href="http://stackoverflow.com/questions/6003819/properties-and-attributes-in-html#answer-6004028" target="_blank" rel="external">what’s the difference?</a>)</li>
<li><code>.camel</code> - transform the kebab-case attribute name into camelCase. (supported since 2.1.0)</li>
</ul>
</li>
<li><p><strong>用法：</strong></p>
<p>动态地绑定一个或多个特性，或一个组件 prop 到表达式。</p>
<p>在绑定 <code>class</code> 或 <code>style</code> 特性时，支持其它类型的值，如数组或对象。可以通过下面的教程链接查看详情。</p>
<p>在绑定 prop 时，prop 必须在子组件中声明。可以用修饰符指定不同的绑定类型。</p>
<p>没有参数时，可以绑定到一个包含键值对的对象。注意此时 <code>class</code> 和 <code>style</code> 绑定不支持数组和对象。</p>
</li>
<li><p><strong>示例：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 绑定一个属性 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">"imageSrc"</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 缩写 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">"imageSrc"</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- with inline string concatenation --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">"'/path/to/images/' + fileName"</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- class 绑定 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">"&#123; red: isRed &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">"[classA, classB]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">"[classA, &#123; classB: isB, classC: isC &#125;]"</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- style 绑定 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">"&#123; fontSize: size + 'px' &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">"[styleObjectA, styleObjectB]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 绑定一个有属性的对象 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind</span>=<span class="string">"&#123; id: someProp, 'other-attr': otherProp &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 通过 prop 修饰符绑定 DOM 属性 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:text-content.prop</span>=<span class="string">"text"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- prop 绑定. “prop” 必须在 my-component 中声明。 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">:prop</span>=<span class="string">"someThing"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- XLink --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">svg</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">:xlink:special</span>=<span class="string">"foo"</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></div></pre></td></tr></table></figure>
<p>The <code>.camel</code> modifier allows camelizing a <code>v-bind</code> attribute name when using in-DOM templates, e.g. the SVG <code>viewBox</code> attribute:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">:view-box.camel</span>=<span class="string">"viewBox"</span>&gt;</span><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></div></pre></td></tr></table></figure>
<p><code>.camel</code> is not needed if you are using string templates, or compiling with <code>vue-loader</code>/<code>vueify</code>.</p>
</li>
<li><p><strong>参考：</strong></p>
<ul>
<li><a href="../guide/class-and-style.html">Class 与 Style 绑定</a></li>
<li><a href="../guide/components.html#Props">组件 - 组件 Props</a></li>
</ul>
</li>
</ul>
<h3 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h3><ul>
<li><p><strong>类型：</strong> 随表单控件类型不同而不同。</p>
</li>
<li><p><strong>限制：</strong></p>
<ul>
<li><code>&lt;input&gt;</code></li>
<li><code>&lt;select&gt;</code></li>
<li><code>&lt;textarea&gt;</code></li>
<li>components</li>
</ul>
</li>
<li><p><strong>修饰符：</strong></p>
<ul>
<li><a href="../guide/forms.html#lazy"><code>.lazy</code></a> - 取代 <code>input</code> 监听 <code>change</code> 事件</li>
<li><a href="../guide/forms.html#number"><code>.number</code></a> - 输入字符串转为数字</li>
<li><a href="../guide/forms.html#trim"><code>.trim</code></a> - 输入首尾空格过滤</li>
</ul>
</li>
<li><p><strong>用法：</strong></p>
<p>在表单控件或者组件上创建双向绑定。细节请看下面链接的教程。</p>
</li>
<li><p><strong>参考：</strong></p>
<ul>
<li><a href="../guide/forms.html">表单控件绑定</a></li>
<li><a href="../guide/components.html#使用自定义事件的表单输入组件">组件 - 在输入组件上使用自定义事件</a></li>
</ul>
</li>
</ul>
<h3 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h3><ul>
<li><p><strong>不需要表达式</strong></p>
</li>
<li><p><strong>用法：</strong></p>
<p>跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。</p>
</li>
<li><p><strong>示例：</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-pre</span>&gt;</span>&#123;&#123; this will not be compiled &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h3><ul>
<li><p><strong>不需要表达式</strong></p>
</li>
<li><p><strong>用法：</strong></p>
<p>这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 <code>[v-cloak] { display: none }</code> 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。</p>
</li>
<li><p><strong>示例：</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><div class="line"><span class="selector-attr">[v-cloak]</span> &#123;</div><div class="line">  <span class="attribute">display</span>: none;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-cloak</span>&gt;</span></div><div class="line">  &#123;&#123; message &#125;&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p><div> 不会显示，直到编译结束。</div></p>
</li>
</ul>
<h3 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h3><ul>
<li><p><strong>不需要表达式</strong></p>
</li>
<li><p><strong>详细：</strong></p>
<p>只渲染元素和组件<strong>一次</strong>。随后的重新渲染,元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 单个元素 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">v-once</span>&gt;</span>This will never change: &#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 有子元素 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-once</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>comment<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;msg&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 组件 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">my-component</span> <span class="attr">v-once</span> <span class="attr">:comment</span>=<span class="string">"msg"</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- v-for 指令--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"i in list"</span> <span class="attr">v-once</span>&gt;</span>&#123;&#123;i&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>参考：</strong></p>
<ul>
<li><a href="../guide/syntax.html#插值">数据绑定语法- 插值</a></li>
<li><a href="../guide/components.html#使用-v-once-的低级静态组件-Cheap-Static-Component">组件 - 使用 v-once 实现轻量的静态组件</a></li>
</ul>
</li>
</ul>
<h2 id="特殊属性"><a href="#特殊属性" class="headerlink" title="特殊属性"></a>特殊属性</h2><h3 id="key"><a href="#key" class="headerlink" title="key"></a>key</h3><ul>
<li><p><strong>示例：</strong> <code>string</code></p>
<p><code>key</code> 的特殊属性主要用在 Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes。如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用key，它会基于key的变化重新排列元素顺序，并且会移除key不存在的元素。</p>
<p>有相同父元素的子元素必须有<strong>独特的key</strong>。重复的key会造成渲染错误。</p>
<p>最常见的用例是结合 <code>v-for</code>:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure>
<p>它也可以用于强制替换元素/组件而不是重复使用它。当你遇到如下场景时它可能会很有用:</p>
<ul>
<li>完整地触发组件的生命周期钩子</li>
<li>触发过渡</li>
</ul>
<p>例如:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">:key</span>=<span class="string">"text"</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div></pre></td></tr></table></figure>
<p>当 <code>text</code> 发生改变时，<code>&lt;span&gt;</code> 会随时被更新，因此会触发过渡。</p>
</li>
</ul>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><ul>
<li><p><strong>类型：</strong> <code>string</code></p>
<p><code>ref</code> 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 <code>$refs</code> 对象上。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素; 如果用在子组件上，引用就指向组件实例:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="comment">&lt;!-- vm.$refs.p will be the DOM node --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">ref</span>=<span class="string">"p"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- vm.$refs.child will be the child comp instance --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">child-comp</span> <span class="attr">ref</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">child-comp</span>&gt;</span></div></pre></td></tr></table></figure>
<p>当 <code>v-for</code> 用于元素或组件的时候，引用信息将是包含 DOM 节点或组件实例的数组。</p>
<p>关于ref注册时间的重要说明: 因为ref本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在！<code>$refs</code> 也不是响应式的，因此你不应该试图用它在模版中做数据绑定。</p>
</li>
<li><p><strong>参考：</strong> <a href="../guide/components.html#子组件索引">子组件 Refs</a></p>
</li>
</ul>
<h3 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h3><ul>
<li><p><strong>类型：</strong> <code>string</code></p>
<p>用于标记往哪个slot中插入子组件内容。</p>
<p>详细用法，请参考下面指南部分的链接。</p>
</li>
<li><p><strong>参考：</strong> <a href="../guide/components.html#具名-Slot">具名 Slots</a></p>
</li>
</ul>
<h2 id="内置的组件"><a href="#内置的组件" class="headerlink" title="内置的组件"></a>内置的组件</h2><h3 id="component"><a href="#component" class="headerlink" title="component"></a>component</h3><ul>
<li><p><strong>Props：</strong></p>
<ul>
<li><code>is</code> - string | ComponentDefinition | ComponentConstructor</li>
<li><code>inline-template</code> - boolean</li>
</ul>
</li>
<li><p><strong>用法：</strong></p>
<p>渲染一个“元组件”为动态组件。依 <code>is</code> 的值，来决定哪个组件被渲染。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 动态组件由 vm 实例的属性值 `componentId` 控制 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"componentId"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 也能够渲染注册过的组件或 prop 传入的组件 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"$options.components.child"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>参考：</strong> <a href="../guide/components.html#动态组件">动态组件</a></p>
</li>
</ul>
<h3 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h3><ul>
<li><p><strong>Props：</strong></p>
<ul>
<li><code>name</code> - string, 用于自动生成 CSS 过渡类名。例如：<code>name: &#39;fade&#39;</code> 将自动拓展为<code>.fade-enter</code>，<code>.fade-enter-active</code>等。默认类名为 <code>&quot;v&quot;</code></li>
<li><code>appear</code> - boolean, 是否在初始渲染时使用过渡。默认为 <code>false</code>。</li>
<li><code>css</code> - boolean, 是否使用 CSS 过渡类。默认为 <code>true</code>。如果设置为 <code>false</code>，将只通过组件事件触发注册的 JavaScript 钩子。</li>
<li><code>type</code> - string, 指定过渡事件类型，侦听过渡何时结束。有效值为 <code>&quot;transition&quot;</code> 和 <code>&quot;animation&quot;</code>。默认 Vue.js 将自动检测出持续时间长的为过渡事件类型。</li>
<li><code>mode</code> - string, 控制离开/进入的过渡时间序列。有效的模式有 <code>&quot;out-in&quot;</code> 和 <code>&quot;in-out&quot;</code>；默认同时生效。</li>
<li><code>enter-class</code> - string</li>
<li><code>leave-class</code> - string</li>
<li><code>enter-active-class</code> - string</li>
<li><code>leave-active-class</code> - string</li>
<li><code>appear-class</code> - string</li>
<li><code>appear-active-class</code> - string</li>
</ul>
</li>
<li><p><strong>事件：</strong></p>
<ul>
<li><code>before-enter</code></li>
<li><code>enter</code></li>
<li><code>after-enter</code></li>
<li><code>before-leave</code></li>
<li><code>leave</code></li>
<li><code>after-leave</code></li>
<li><code>before-appear</code></li>
<li><code>appear</code></li>
<li><code>after-appear</code></li>
</ul>
</li>
<li><p><strong>用法：</strong></p>
<p><code>&lt;transition&gt;</code> 元素作为单个元素/组件的过渡效果。<code>&lt;transition&gt;</code> 不会渲染额外的 DOM 元素，也不会出现在检测过的组件层级中。它只是将内容包裹在其中，简单的运用过渡行为。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 简单元素 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">"ok"</span>&gt;</span>toggled content<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 动态组件 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">"fade"</span> <span class="attr">mode</span>=<span class="string">"out-in"</span> <span class="attr">appear</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"view"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 事件钩子 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"transition-demo"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">transition</span> @<span class="attr">after-enter</span>=<span class="string">"transitionComplete"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-show</span>=<span class="string">"ok"</span>&gt;</span>toggled content<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><div class="line"><span class="keyword">new</span> Vue(&#123;</div><div class="line">  ...</div><div class="line">  methods: &#123;</div><div class="line">    <span class="attr">transitionComplete</span>: <span class="function"><span class="keyword">function</span> (<span class="params">el</span>) </span>&#123;</div><div class="line">      <span class="comment">// 传入 'el' 这个 DOM 元素作为参数。</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line">&#125;).$mount(<span class="string">'#transition-demo'</span>)</div></pre></td></tr></table></figure>
</li>
<li><p><strong>参考：</strong> <a href="../guide/transitions.html">过渡：进入，离开和列表</a></p>
</li>
</ul>
<h3 id="transition-group"><a href="#transition-group" class="headerlink" title="transition-group"></a>transition-group</h3><ul>
<li><p><strong>Props：</strong></p>
<ul>
<li><code>tag</code> - string, 默认为 <code>span</code></li>
<li><code>move-class</code> - 覆盖移动过渡期间应用的 CSS 类。</li>
<li>除了 <code>mode</code>，其他特性和 <code>&lt;transition&gt;</code> 相同。</li>
</ul>
</li>
<li><p><strong>事件：</strong></p>
<ul>
<li>事件和 <code>&lt;transition&gt;</code> 相同.</li>
</ul>
</li>
<li><p><strong>用法：</strong></p>
<p><code>&lt;transition-group&gt;</code> 元素作为多个元素/组件的过渡效果。<code>&lt;transition-group&gt;</code> 渲染一个真实的 DOM 元素。默认渲染 <code>&lt;span&gt;</code>，可以通过 <code>tag</code> 属性配置哪个元素应该被渲染。</p>
<p>注意，每个 <code>&lt;transition-group&gt;</code> 的子节点必须有 <strong>独立的key</strong> ，动画才能正常工作</p>
<p><code>&lt;transition-group&gt;</code> 支持通过 CSS transform 过渡移动。当一个子节点被更新，从屏幕上的位置发生变化，它将会获取应用 CSS 移动类（通过 <code>name</code> 属性或配置 <code>move-class</code> 属性自动生成）。如果 CSS <code>transform</code> 属性是“可过渡”属性，当应用移动类时，将会使用 <a href="https://aerotwist.com/blog/flip-your-animations/" target="_blank" rel="external">FLIP 技术</a> 使元素流畅地到达动画终点。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">transition-group</span> <span class="attr">tag</span>=<span class="string">"ul"</span> <span class="attr">name</span>=<span class="string">"slide"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">"item in items"</span> <span class="attr">:key</span>=<span class="string">"item.id"</span>&gt;</span></div><div class="line">    &#123;&#123; item.text &#125;&#125;</div><div class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">transition-group</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong>参考：</strong> <a href="../guide/transitions.html">过渡：进入，离开和列表</a></p>
</li>
</ul>
<h3 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h3><ul>
<li><p><strong>Props:</strong></p>
<ul>
<li><code>include</code> - string or RegExp. Only components matched by this will be cached.</li>
<li><code>exclude</code> - string or RegExp. Any component matched by this will not be cached.</li>
</ul>
</li>
<li><p><strong>用法：</strong></p>
<p><code>&lt;keep-alive&gt;</code> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 <code>&lt;transition&gt;</code> 相似，<code>&lt;keep-alive&gt;</code> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。</p>
<p>当组件在 <code>&lt;keep-alive&gt;</code> 内被切换，它的 <code>activated</code> 和 <code>deactivated</code> 这两个生命周期钩子函数将会被对应执行。</p>
<p>主要用于保留组件状态或避免重新渲染。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 基本 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"view"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 多个条件判断的子组件 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">comp-a</span> <span class="attr">v-if</span>=<span class="string">"a &gt; 1"</span>&gt;</span><span class="tag">&lt;/<span class="name">comp-a</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">comp-b</span> <span class="attr">v-else</span>&gt;</span><span class="tag">&lt;/<span class="name">comp-b</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- 和 &lt;transition&gt; 一起使用 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">transition</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"view"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
<li><p><strong><code>include</code> and <code>exclude</code></strong></p>
<blockquote>
<p>New in 2.1.0</p>
</blockquote>
<p>The <code>include</code> and <code>exclude</code> props allow components to be conditionally cached. Both props can either be a comma-delimited string or a RegExp:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="comment">&lt;!-- comma-delimited string --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">include</span>=<span class="string">"a,b"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"view"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">&lt;!-- regex (use v-bind) --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">:include</span>=<span class="string">"/a|b/"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">"view"</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></div></pre></td></tr></table></figure>
<p>The match is first checked on the component’s own <code>name</code> option, then its local registration name (the key in the parent’s <code>components</code> option) if the <code>name</code> option is not available. Anonymous components cannot be matched against.</p>
<p class="tip"><code>&lt;keep-alive&gt;</code> 不会在函数式组件中正常工作，因为它们没有缓存实例。</p>
</li>
<li><p><strong>参考：</strong> <a href="../guide/components.html#keep-alive">动态组件 - keep-alive</a></p>
</li>
</ul>
<h3 id="slot-1"><a href="#slot-1" class="headerlink" title="slot"></a>slot</h3><ul>
<li><p><strong>Props：</strong></p>
<ul>
<li><code>name</code> - string, 用于命名插槽。</li>
</ul>
</li>
<li><p><strong>Usage:</strong></p>
<p><code>&lt;slot&gt;</code> 元素作为组件模板之中的内容分发插槽。 <code>&lt;slot&gt;</code> 元素自身将被替换。</p>
<p>详细用法，请参考下面教程的链接。</p>
</li>
<li><p><strong>参考：</strong> <a href="../guide/components.html#使用Slots分发内容">使用Slots分发内容</a></p>
</li>
</ul>
<h2 id="VNode接口"><a href="#VNode接口" class="headerlink" title="VNode接口"></a>VNode接口</h2><ul>
<li>请参考<a href="https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js" target="_blank" rel="external">VNode class declaration</a>.</li>
</ul>
<h2 id="服务端渲染"><a href="#服务端渲染" class="headerlink" title="服务端渲染"></a>服务端渲染</h2><ul>
<li>请参考<a href="https://github.com/vuejs/vue/tree/dev/packages/vue-server-renderer" target="_blank" rel="external">vue-server-renderer package documentation</a>.</li>
</ul>

    
    <div class="footer">
      发现错误？想参与编辑？
      <a href="https://github.com/vuejs/cn.vuejs.org/blob/master/src/v2/api/index.md" target="_blank">
        在 Github 上编辑此页！
      </a>
    </div>
</div>

                
            </div>
            <script src="/js/smooth-scroll.min.js"></script>
        

        <!-- main custom script for sidebars, version selects etc. -->
        <script src="/js/common.js"></script>

        <!-- ga -->
        <script>
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
          (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

          ga('create', 'UA-46852172-1', 'cn.vuejs.org');
          ga('send', 'pageview');
        </script>

        <!-- search -->
        <link href="//cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css" rel='stylesheet' type='text/css'>
        <link rel="stylesheet" href="/css/search.css">
        <script src="//cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script>
        <script>
        [
          '#search-query-nav',
          '#search-query-sidebar'
        ].forEach(function (selector) {
          if (!document.querySelector(selector)) return
          // search index defaults to v2
          var match = window.location.pathname.match(/^\/(v\d+)/)
          var version = match ? match[1] : 'v2'
          docsearch({
            appId: 'BH4D9OD16A',
            apiKey: '5638280abff9d207417bb03be05f0b25',
            indexName: 'vuejs_cn2',
            inputSelector: selector,
            algoliaOptions: { facetFilters: ["version:" + version] }
          })
        })
        </script>

        <!-- fastclick -->
        <script src="//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js"></script>
        <script>
        document.addEventListener('DOMContentLoaded', function() {
          FastClick.attach(document.body)
        }, false)
        </script>
    </body>
</html>
